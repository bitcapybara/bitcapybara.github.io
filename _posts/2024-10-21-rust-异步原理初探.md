---
layout: post
title: Rust 异步原理初探
date: 2024-10-21 22:46 +0800
categories: [Rust]
tags: [rust, async, generator, coroutine]
---

# 异步生成器和状态机

编写 Rust 异步代码的核心是实现 `Future` trait, 在日常的编码中，通常有两种方式来实现一个 Future

1. 手动实现 `Future` trait

```rust
struct S;

impl Future for S {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        Poll::Ready(1)
    }
}
```

2. 使用 `async` 关键字

```rust
// async function
async fn foo() -> usize {
    1
}

// async block
let bar = async { 1 };
```

async 实际上是语法糖，`async function` 和 `async block` 返回一个 `impl Future` 类型，即在编译期，编译器帮我们创建了一个实现了 `Future` trait 的结构。

那么这个生成的结构具体是什么呢？和 async 配套使用的 await, 脱糖之后是什么样，他们究竟做了什么呢？

假设我们要实现一个简单的异步流程，尝试使用伪代码将它改写为一个实现了 `Future` trait 的结构

```rust
async fn content_len() -> usize {
    let foo_content: Vec<u8> = read_from_file("foo.txt").await;
    let bar_content: Vec<u8> = read_from_file("bar.txt").await;
    foo_content.len() + bar_content.len()
}
```

foo 方法的执行有四种状态：未执行，读取文件中，发送中，发送结束，我们在实现 Future trait 时需要构造一个状态机

```rust

enum ContentLenState {
    Init,
    ReadingFromFoo {
        fut: impl Future<Output = Vec<u8>>
    },
    ReadingFromBar {
        foo_content: Vec<u8>,
        fut: impl Future<Output = Vec<u8>>
    },
    End
}

impl Future for ContentLenState {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            // 这里需要处理 pin，此处忽略
            match self {
                // 初始化第一个 future
                ContentLenState::Init => {
                    *self = ReadingFromFoo {
                        fut: read_from_file("foo.txt")
                    };
                }
                // poll 第一个 future，如果成功，则初始化第二个 future，否则返回 pending 等待下一次 poll
                ContentLenState::ReadingFromFoo { fut } => match fut.poll(cx) {
                    Poll::Ready(foo_content) => {
                        *self = ReadingFromBar {
                            foo_content,
                            fut: read_from_file("bar.txt")
                        };
                    },
                    Poll::Pending => return Poll::Pending,
                }
                // poll 第二个 future，如果成功，则返回 Poll::Ready 表示 future 完成，否则返回 pending 等待下一次 poll
                ContentLenState::ReadingFromBar {
                    foo_content,
                    fut,
                } => match fut {
                    Poll::Ready(bar_content) => {
                        *self = ContentLenState::End;
                        return Poll::Ready(foo_content.len() + bar_content.len());
                    },
                    Poll::Pending => return Poll::Pending,
                }
                // 返回 Poll::Ready 后不可以再对 Future 进行 poll
                End => panic!("poll called after Poll::Ready was returned")
            }
        }
    } 
}
```

我们来看看编译器是怎么实现的

rust 代码编译时，会产生多个中间编译产物，其中编译生成的 HIR 可以大致看出 async func 的实现思路，在 [Rust Playground](https://play.rust-lang.org/) 中可以直接生成 HIR 并查看，HIR 也可以在本地使用 Rust 工具链命令生成

我们从最简单的一个异步函数开始看
```rust
struct S;

impl Future for S {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        Poll::Ready(1)
    }
}

async fn test() -> usize {
    S.await
}
```

test 方法的 HIR 长这个样子，可以看到，`.await` 语法糖，在脱糖后会展开成一段带有循环的代码

```rust
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

async fn test()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    {
        {
                let _t =
                    {
                        match #[lang = "into_future"](S) {
                                mut __awaitee =>
                                    loop {
                                            match unsafe {
                                                            #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                #[lang = "get_context"](_task_context))
                                                        } {
                                                    #[lang = "Ready"] {  0: result } => break result,
                                                    #[lang = "Pending"] {} => { }
                                                }
                                            _task_context = (yield ());
                                        },
                            }
                    };
                _t
            }
    }
```

用标准库语法来美化一下

```rust
async fn test() -> /*impl Trait*/ {
    |mut _task_context: ResumeTy| {
        {
            let _t = {
                match IntoFuture::into_future(S) {
                    mut __awaitee => loop {
                        match unsafe {
                            Future::poll(
                                Pin::new_unchecked(&mut __awaitee),
                                std::future::get_context(_task_context),
                            )
                        } {
                            Poll::Ready(result) => break result,
                            Poll::Pending => {}
                        }
                        _task_context = (yield ());
                    },
                };
            };
            _t
        }
    }
}
```

看到 yield 关键字想到了什么？生成器！在 Rust 中，生成器也叫 [协程](https://doc.rust-lang.org/std/ops/trait.Coroutine.html), 目前为止还是一个 nightly 特性

```rust
pub trait Coroutine<R = ()> {
    type Yield;
    type Return;

    // Required method
    fn resume(
        self: Pin<&mut Self>,
        arg: R,
    ) -> CoroutineState<Self::Yield, Self::Return>;
}
```

它可以让用户很方便地实现一个状态机，当执行到 yield 时，Coroutine 会返回，并且会保存当前状态，当用户下次调用 resume 方法时，会从上次 yield 的地方恢复执行，上下文环境也会恢复到上次退出挂起的状态

```rust
let mut coroutine = #[coroutine] || {
    yield 1;
    "foo"
};
```

现在我们可以用进一步美化上面的示例，使他更贴近 Rust 语法

```rust
struct CoroutineFuture<C>(C);

fn test<C>() -> CoroutineFuture<C>
where
    C: Coroutine<ResumeTy, Yield = (), Return = ()>,
{
    |mut _task_context: ResumeTy| {
        let _t = {
            match IntoFuture::into_future(S) {
                mut __awaitee => loop {
                    match unsafe {
                        Future::poll(
                            Pin::new_unchecked(&mut __awaitee),
                            std::future::get_context(_task_context),
                        )
                    } {
                        Poll::Ready(result) => break result,
                        Poll::Pending => {}
                    }
                    _task_context = (yield ());
                },
            };
        };
        _t
    }
}
```

因为 test 方法返回一个 Future，而 Coroutine 是没有实现 Future trait 的，所以编译器在这里有一些魔法，会把 Coroutine 转换为一个实现了 Future trait 的结构，类似于上面的 CoroutineFuture。而 CoroutineFuture 的实现如下

```rust

struct CoroutineFuture<C>(C);

impl<C: Coroutine<ResumeTy, Yield = ()>> Future for CoroutineFuture<C> {

    type Output = C::Return;
 
    fn poll(self: Pin<&mut Self>, ctx: &mut Context<'_>) -> Poll<Self::Output> {
        unsafe {
            let this: Pin<&mut C> = Pin::new_unchecked(&mut Pin::into_inner_unchecked(self).0);

            // 这里把 ctx 转换为 ResumeTy 参数，这里暂时使用伪代码代替
            let resume_ty = transmute_ctx_to_resumety(ctx);

            // 调用 resume 方法，时状态机取得进展
            match this.resume(resume_ty) {
                CoroutineState::Yielded(()) => Poll::Pending,
                CoroutineState::Complete(r) => Poll::Ready(r),
            }
        }
    }
}
```

test 方法返回的 Future，在每次 poll 的时候，会对其内部的协程调用 resume 方法来获取进展

综上所述，async 和 await 这两个语法糖在编译器各自做了两件事：

1. async 将其包含的代码（function 或 block）转换为一个带有协程状态机的 Future，每次 poll 时会调用 resume 方法使状态机取得进展
2. await 在协程里循环 poll 关联的 future，在 future 返回 pending 时 yield 挂起协程，并在 future 结束后继续执行后续代码

现在我们再来看我们上面研究的 content_len 方法，它展开为 HIR 是这样的

```rust
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
async fn content_len()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    {
        {
                let _t =
                    {
                        let foo_content: Vec<u8> =
                            match #[lang = "into_future"](read_from_file("foo.txt")) {
                                    mut __awaitee =>
                                        loop {
                                                match unsafe {
                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                    #[lang = "get_context"](_task_context))
                                                            } {
                                                        #[lang = "Ready"] {  0: result } => break result,
                                                        #[lang = "Pending"] {} => { }
                                                    }
                                                _task_context = (yield ());
                                            },
                                };
                        let bar_content: Vec<u8> =
                            match #[lang = "into_future"](read_from_file("bar.txt")) {
                                    mut __awaitee =>
                                        loop {
                                                match unsafe {
                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                    #[lang = "get_context"](_task_context))
                                                            } {
                                                        #[lang = "Ready"] {  0: result } => break result,
                                                        #[lang = "Pending"] {} => { }
                                                    }
                                                _task_context = (yield ());
                                            },
                                };
                        foo_content.len() + bar_content.len()
                    };
                _t
            }
    }

async fn read_from_file()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    { { let _t = { ::alloc::vec::Vec::new() }; _t } }
```

在最后生成的状态机里，两个 read_from_file 方法各自生成里一段循环代码，因为 Coroutine 在 yield 时会保存状态，所以不需要再定义 ContentLenState 来手动维护状态

# Future trait 中的 Pin

在上面的讨论中，我们已经知道了 async 最后也是生成了一个 Future trait, 我们都注意到，Future 中的 self 的类型是 `Pin<&mut Self>`，这是为什么呢？在 [标准库文档](https://doc.rust-lang.org/std/pin/index.html) 中我们可以知道，Pin 包含的类型在内存中是不可移动的，与之相对应的是 Unpin trait，它是一个 auto trait，标准库定义的大部分类型都自动实现 Unpin，如果你的结构中只包含 Unpin 类型的字段，那么也会自动实现 Unpin trait, 但是如果有其中一个字段是 !Unpin 的，就代表它没有实现 Unpin，那么整个结构就是 !Unpin 的了。那么什么样的类型需要 Pin 呢？我们看下面的示例

```rust
#[derive(Debug)]
struct SelfRef {
    value: String,
    pointer_to_value: *const String,
}

impl SelfRef {
    fn new(txt: &str) -> Self {
        SelfRef {
            value: String::from(txt),
            pointer_to_value: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.value;
        self.pointer_to_value = self_ref;
    }

    fn value(&self) -> &str {
        &self.value
    }

    fn pointer_to_value(&self) -> &String {
        assert!(!self.pointer_to_value.is_null(),
            "Test::b called without Test::init being called first");
        unsafe { &*(self.pointer_to_value) }
    }
}
```

在这里，SelfRef 包含两个字段，value 存储一个 字符串，pointer_to_value 存储指向 value 字段的指针，这个结构就是自引用结构，如果这个结构在内存中发生了移动，比如 value 移动到了另一个内存块，那么 pointer_to_value 就失效了，这会带来很大的安全隐患。那么怎么保证 SelfRef 不会在内存中移动呢？答案就是 Pin

```rust
struct Unmovable {
    data: String,
    slice: NonNull<String>,
    _pin: PhantomPinned,
}

impl Unmovable {
    fn new(data: String) -> Pin<Box<Self>> {
        let res = Unmovable {
            data,
            slice: NonNull::dangling(),
            _pin: PhantomPinned,
        };
        let mut boxed = Box::pin(res);

        let slice = NonNull::from(&boxed.data);
        unsafe {
            let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).slice = slice;
        }
        boxed
    }
}
```

在 Unmovable 结构中，_pin 字段的类型 PhantomPinned 是 !Unpin 的，所以此时 Unmovable 是 !Unpin 的。构造出的 Pin<Box<Unmovable>> 不允许在内存中移动，如果有移动操作，会导致编译报错。

那么问题来了，在日常编写 Future trait 时，我们好像也没有定义过自引用结构，日常开发中也几乎没有见过，为什么 Future trait 要多此一举将 self 定义为 Pin 类型呢？原因在于 async 关键字生成的状态机里，自引用结构是很常见的，看下面的示例

```rust
async fn pin_example() -> i32 {
    let array = [1, 2, 3];
    let element = &array[2];
    async_write_file("foo.txt", element.to_string()).await;
    *element
}
```

上面的示例中，element 是对 array 变量的引用，在这个方法翻译为状态机时，因为 array 和 element 都存在，所以状态机会保存这两个变量，大概是这样

```rust
struct WaitingOnWriteState {
    array: [1, 2, 3],
    element: 0x1001c, // address of the last array element
}
```

可以看出，这时 WaitingOnWriteState 就是一个自引用结构，也就是说，在 async 代码中，只要有引用存在，最后状态机就会生成自引用结构，而这种场景实际上非常常见。这就是 Future trait 需要 self 为 Pin 类型的原因。

# Context, Excutor 和 Reactor

Future trait 中，poll 方法的第二个参数是 Context 类型，这又是个什么类型呢？目前我们只需要知道，Context 中包含一个 Waker，Waker 有一些 wake() 方法，这个方法是用来实现一个通知机制。我们知道，Future trait 是惰性的，如果没有调用 poll 方法，它不会在后台自己运行来推进状态机，而调用 poll 的任务，就交给了第三方的异步运行时或者是异步库来做了。

Waker 可由 RawWaker 构建，而 RawWaker 的行为由运行时库通过 vtable 自行定义

```rust
pub const unsafe fn from_raw(waker: RawWaker) -> Waker;

pub const fn new(data: *const (), vtable: &'static RawWakerVTable) -> RawWaker;
```

smol 的 wake 实现在 async-task/src/raw.rs:232 行，调用 427 行的 schedule 方法，最后调用了 async-executor 中 lib.rs:348 行的 schedule

```rust

fn schedule(&self) -> impl Fn(Runnable) + Send + Sync + 'static {
    let state = self.state_as_arc();

    // TODO: If possible, push into the current local queue and notify the ticker.
    move |runnable| {
        state.queue.push(runnable).unwrap();
        state.notify();
    }
}
```

smol::spawn 在每个线程上创建一个 Executor, 调用 Executor::run 方法，不停获取任务执行

smol::spawn 里的 block_on(smol/src/spawn.rs:50)，里面也会生成 waker

Future trait 中，poll 方法的第二个参数时 Context 类型，用于通知运行时 Future 已准备好 poll，那么这个通知机制是如何实现的呢？运行时又是如何来调度 Future 任务并进行 poll 的呢？

smol 是个精简又功能完备的异步运行时，代码量不大且通俗易懂，我们可以从 smol 入手来学习异步运行时调度的底层原理（为便于讲解对实际代码进行了一定程度的精简）。

首先我们从 smol::spawn 开始，它接收一个 Future，并在后台执行

```rust
// smol/src/spawn.rs
pub fn spawn<T: Send + 'static>(future: impl Future<Output = T> + Send + 'static) -> Task<T> {
    static GLOBAL: OnceCell<Executor<'_>> = OnceCell::new();

    fn global() -> &'static Executor<'static> {
        GLOBAL.get_or_init_blocking(|| {
            /* ... */

            for n in 1..=num_threads {
                thread::Builder::new()
                    .name(format!("smol-{}", n))
                    .spawn(|| loop { // 这个 loop 是为了在 block_on panic 后重新执行
                        catch_unwind(|| block_on(global().run(future::pending::<()>()))).ok();
                    })
                    .expect("cannot spawn executor thread");
            }

            Executor::new()
        })
    }

    // TODO: Vtable waker
    global().spawn(future)
}
```

smol 会构造一个全局唯一的执行器 Executor，在后台启动多个线程，在每个线程上运行执行器的 run 方法返回的 Future。

我们先来看 block_on 方法

```rust
pub fn block_on<T>(future: impl Future<Output = T>) -> T {

    // Creates a parker and an associated waker that unparks it.
    fn parker_and_waker() -> (Parker, Waker, Arc<AtomicBool>) {
        // 用于将线程挂起和恢复线程执行
        let (p, u) = parking::pair();

        // This boolean is set to `true` when the current thread is blocked on I/O.
        let io_blocked = Arc::new(AtomicBool::new(false));

        // 这个 waker 可以将线程恢复执行
        let waker = BlockOnWaker::create(io_blocked.clone(), u);

        (p, waker, io_blocked)
    }

    thread_local! {
        // Cached parker and waker for efficiency.
        static CACHE: RefCell<(Parker, Waker, Arc<AtomicBool>)> = RefCell::new(parker_and_waker());

        // Indicates that the current thread is polling I/O, but not necessarily blocked on it.
        static IO_POLLING: Cell<bool> = const { Cell::new(false) };
    }

    struct BlockOnWaker {
        io_blocked: Arc<AtomicBool>,
        unparker: parking::Unparker,
    }

    impl BlockOnWaker {
        fn create(io_blocked: Arc<AtomicBool>, unparker: parking::Unparker) -> Waker {
            Waker::from(Arc::new(BlockOnWaker {
                io_blocked,
                unparker,
            }))
        }
    }

    impl std::task::Wake for BlockOnWaker {
        fn wake_by_ref(self: &Arc<Self>) {
            if self.unparker.unpark() {
                // Check if waking from another thread and if currently blocked on I/O.
                if !IO_POLLING.with(Cell::get) && self.io_blocked.load(Ordering::SeqCst) {
                    Reactor::get().notify();
                }
            }
        }

        fn wake(self: Arc<Self>) {
            self.wake_by_ref()
        }
    }

    CACHE.with(|cache| {

        let (p, waker, io_blocked) = /* get parker and waker */;

        pin!(future);

        // 构造一个 Context 用于执行 Future 的 poll 方法
        let cx = &mut Context::from_waker(waker);

        loop {
            // 对 Future 执行 poll，如果 future 完成则直接返回
            if let Poll::Ready(t) = future.as_mut().poll(cx) {
                p.park_timeout(Duration::from_secs(0));
                tracing::trace!("completed");
                return t;
            }

            // Check if a notification was received.
            if p.park_timeout(Duration::from_secs(0)) {
                tracing::trace!("notified");

                // Try grabbing a lock on the reactor to process I/O events.
                if let Some(mut reactor_lock) = Reactor::get().try_lock() {
                    // First let wakers know this parker is processing I/O events.
                    IO_POLLING.with(|io| io.set(true));
                    let _guard = CallOnDrop(|| {
                        IO_POLLING.with(|io| io.set(false));
                    });

                    // Process available I/O events.
                    reactor_lock.react(Some(Duration::from_secs(0))).ok();
                }
                continue;
            }

            // Try grabbing a lock on the reactor to wait on I/O.
            if let Some(mut reactor_lock) = Reactor::get().try_lock() {
                // Record the instant at which the lock was grabbed.
                let start = Instant::now();

                loop {
                    // First let wakers know this parker is blocked on I/O.
                    IO_POLLING.with(|io| io.set(true));
                    io_blocked.store(true, Ordering::SeqCst);
                    let _guard = CallOnDrop(|| {
                        IO_POLLING.with(|io| io.set(false));
                        io_blocked.store(false, Ordering::SeqCst);
                    });

                    // Check if a notification has been received before `io_blocked` was updated
                    // because in that case the reactor won't receive a wakeup.
                    if p.park_timeout(Duration::from_secs(0)) {
                        tracing::trace!("notified");
                        break;
                    }

                    // Wait for I/O events.
                    tracing::trace!("waiting on I/O");
                    reactor_lock.react(None).ok();

                    // Check if a notification has been received.
                    if p.park_timeout(Duration::from_secs(0)) {
                        tracing::trace!("notified");
                        break;
                    }

                    // Check if this thread been handling I/O events for a long time.
                    if start.elapsed() > Duration::from_micros(500) {
                        tracing::trace!("stops hogging the reactor");

                        // This thread is clearly processing I/O events for some other threads
                        // because it didn't get a notification yet. It's best to stop hogging the
                        // reactor and give other threads a chance to process I/O events for
                        // themselves.
                        drop(reactor_lock);

                        // Unpark the "async-io" thread in case no other thread is ready to start
                        // processing I/O events. This way we prevent a potential latency spike.
                        unparker().unpark();

                        // Wait for a notification.
                        p.park();
                        break;
                    }
                }
            } else {
                // Wait for an actual notification.
                tracing::trace!("sleep until notification");
                p.park();
            }
        }
    })
}
```

在 block_on 中构造了 parker 和 unparker，用来挂起线程和恢复线程。BlockOnWaker 是由 unparker 构造的，并且在 wake 方法里面调用了 unpark，对 执行器 Future 执行 poll 时，会把这个 unparker 作为 Context 参数传递。

当执行器 Future 返回 pending 时，block_on 会挂起线程，然后当执行器 Future 在内部调用了 waker 的 wake 方法时，又回恢复 block_on 的循环。稍后我们可以看到，执行器 Future 实际上永远不会返回 Ready，所以 block_on 的循环永远不会退出。

可以注意到，在 block_on 每次循环中调用了 Reactor::get() 方法获取了一个全局的反应器，并且执行了 Reactor::react 方法。

```rust
pub(crate) fn react(&mut self, timeout: Option<Duration>) -> io::Result<()> {
    let span = tracing::trace_span!("react");
    let _enter = span.enter();

    let mut wakers = Vec::new();

    // Process ready timers.
    let next_timer = self.reactor.process_timers(&mut wakers);

    // compute the timeout for blocking on I/O events.
    let timeout = match (next_timer, timeout) {
        (None, None) => None,
        (Some(t), None) | (None, Some(t)) => Some(t),
        (Some(a), Some(b)) => Some(a.min(b)),
    };

    // Bump the ticker before polling I/O.
    let tick = self
        .reactor
        .ticker
        .fetch_add(1, Ordering::SeqCst)
        .wrapping_add(1);

    self.events.clear();

    // Block on I/O events.
    let res = match self.reactor.poller.wait(&mut self.events, timeout) {
        // No I/O events occurred.
        Ok(0) => {
            if timeout != Some(Duration::from_secs(0)) {
                // The non-zero timeout was hit so fire ready timers.
                self.reactor.process_timers(&mut wakers);
            }
            Ok(())
        }

        // At least one I/O event occurred.
        Ok(_) => {
            // Iterate over sources in the event list.
            let sources = self.reactor.sources.lock().unwrap();

            for ev in self.events.iter() {
                // Check if there is a source in the table with this key.
                if let Some(source) = sources.get(ev.key) {
                    let mut state = source.state.lock().unwrap();

                    // Collect wakers if a writability event was emitted.
                    for &(dir, emitted) in &[(WRITE, ev.writable), (READ, ev.readable)] {
                        if emitted {
                            state[dir].tick = tick;
                            state[dir].drain_into(&mut wakers);
                        }
                    }

                    // Re-register if there are still writers or readers. This can happen if
                    // e.g. we were previously interested in both readability and writability,
                    // but only one of them was emitted.
                    if !state[READ].is_empty() || !state[WRITE].is_empty() {
                        // Create the event that we are interested in.
                        let event = {
                            let mut event = Event::none(source.key);
                            event.readable = !state[READ].is_empty();
                            event.writable = !state[WRITE].is_empty();
                            event
                        };

                        // Register interest in this event.
                        source.registration.modify(&self.reactor.poller, event)?;
                    }
                }
            }

            Ok(())
        }

        // The syscall was interrupted.
        Err(err) if err.kind() == io::ErrorKind::Interrupted => Ok(()),

        // An actual error occureed.
        Err(err) => Err(err),
    };

    // Wake up ready tasks.
    tracing::trace!("{} ready wakers", wakers.len());
    for waker in wakers {
        // Don't let a panicking waker blow everything up.
        panic::catch_unwind(|| waker.wake()).ok();
    }

    res
}
```

Reactor 是对操作系统底层 epoll/kqueue 等事件处理机制等封装，主要用来处理 IO 事件，和对定时器 Timer 进行轮询。

1. 对于定时器，在创建后添加到 Reactor 中，此时是没有 waker 的，当第一次执行 poll 的时候，会设置 waker 到 Timer 中，Reactor 里轮询 Timer 并对所有到期的 Timer 执行 wake 操作。

2. 对于 IO 事件，创建后添加到 Reactor 的 Poller 中，此时也是没有 waker 的，当对读写操作执行 poll （AsyncRead::poll_read, AsyncWrite::poll_write）时，对读写事件设置 waker，Reactor 轮询时，获取到 Poller 中对应事件就绪后，调用对应的 waker


接下来，我们再来看 Executor::run 方法

smol::spawn 的最后，Executor::spawn 生成的任务是 vtable waker, wake 方法将任务放回队列