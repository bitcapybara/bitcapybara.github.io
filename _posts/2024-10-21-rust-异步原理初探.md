---
layout: post
title: Rust 异步原理初探
date: 2024-10-21 22:46 +0800
categories: [Rust]
tags: [rust, async, generator, coroutine]
---

# 异步生成器和状态机

编写 Rust 异步代码的核心是实现 `Future` trait, 在日常的编码中，通常有两种方式来实现一个 Future

1. 手动实现 `Future` trait

```rust
struct S;

impl Future for S {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        Poll::Ready(1)
    }
}
```

2. 使用 `async` 关键字

```rust
// async function
async fn foo() -> usize {
    1
}

// async block
let bar = async { 1 };
```

async 实际上是语法糖，`async function` 和 `async block` 返回一个 `impl Future` 类型，即在编译期，编译器帮我们创建了一个实现了 `Future` trait 的结构。

那么这个生成的结构具体是什么呢？和 async 配套使用的 await, 脱糖之后是什么样，他们究竟做了什么呢？

假设我们要实现一个简单的异步流程，尝试使用伪代码将它改写为一个实现了 `Future` trait 的结构

```rust
async fn content_len() -> usize {
    let foo_content: Vec<u8> = read_from_file("foo.txt").await;
    let bar_content: Vec<u8> = read_from_file("bar.txt").await;
    foo_content.len() + bar_content.len()
}
```

foo 方法的执行有四种状态：未执行，读取文件中，发送中，发送结束，我们在实现 Future trait 时需要构造一个状态机

```rust

enum ContentLenState {
    Init,
    ReadingFromFoo {
        fut: impl Future<Output = Vec<u8>>
    },
    ReadingFromBar {
        foo_content: Vec<u8>,
        fut: impl Future<Output = Vec<u8>>
    },
    End
}

impl Future for ContentLenState {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            // 这里需要处理 pin，此处忽略
            match self {
                // 初始化第一个 future
                ContentLenState::Init => {
                    *self = ReadingFromFoo {
                        fut: read_from_file("foo.txt")
                    };
                }
                // poll 第一个 future，如果成功，则初始化第二个 future，否则返回 pending 等待下一次 poll
                ContentLenState::ReadingFromFoo { fut } => match fut.poll(cx) {
                    Poll::Ready(foo_content) => {
                        *self = ReadingFromBar {
                            foo_content,
                            fut: read_from_file("bar.txt")
                        };
                    },
                    Poll::Pending => return Poll::Pending,
                }
                // poll 第二个 future，如果成功，则返回 Poll::Ready 表示 future 完成，否则返回 pending 等待下一次 poll
                ContentLenState::ReadingFromBar {
                    foo_content,
                    fut,
                } => match fut {
                    Poll::Ready(bar_content) => {
                        *self = ContentLenState::End;
                        return Poll::Ready(foo_content.len() + bar_content.len());
                    },
                    Poll::Pending => return Poll::Pending,
                }
                // 返回 Poll::Ready 后不可以再对 Future 进行 poll
                End => panic!("poll called after Poll::Ready was returned")
            }
        }
    } 
}
```

我们来看看编译器是怎么实现的

rust 代码编译时，会产生多个中间编译产物，其中编译生成的 HIR 可以大致看出 async func 的实现思路，在 [Rust Playground](https://play.rust-lang.org/) 中可以直接生成 HIR 并查看，HIR 也可以在本地使用 Rust 工具链命令生成

我们从最简单的一个异步函数开始看
```rust
async fn test() -> usize {
    async {1}.await
}
```

它的 HIR 长这个样子

```rust
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

async fn test()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    {
        {
                let _t =
                    {
                        match #[lang = "into_future"](|mut _task_context: ResumeTy|
                                            { 1 }) {
                                mut __awaitee =>
                                    loop {
                                            match unsafe {
                                                            #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                #[lang = "get_context"](_task_context))
                                                        } {
                                                    #[lang = "Ready"] {  0: result } => break result,
                                                    #[lang = "Pending"] {} => { }
                                                }
                                            _task_context = (yield ());
                                        },
                            }
                    };
                _t
            }
    }
```



