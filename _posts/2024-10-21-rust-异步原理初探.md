---
layout: post
title: Rust 异步原理初探
date: 2024-10-21 22:46 +0800
categories: [Rust]
tags: [rust, async, generator, coroutine]
---

## 异步生成器和状态机

编写 Rust 异步代码的核心是实现 `Future` trait, 在日常的编码中，通常有两种方式来实现一个 Future

1. 手动实现 `Future` trait

```rust
struct S;

impl Future for S {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        Poll::Ready(1)
    }
}
```

2. 使用 `async` 关键字

```rust
// async function
async fn foo() -> usize {
    1
}

// async block
let bar = async { 1 };
```

async 实际上是语法糖，`async function` 和 `async block` 返回一个 `impl Future` 类型，即在编译期，编译器帮我们创建了一个实现了 `Future` trait 的结构。

那么这个生成的结构具体是什么呢？和 async 配套使用的 await, 脱糖之后是什么样，他们究竟做了什么呢？

假设我们要实现一个简单的异步流程，尝试使用伪代码将它改写为一个实现了 `Future` trait 的结构

```rust
async fn content_len() -> usize {
    let foo_content: Vec<u8> = read_from_file("foo.txt").await;
    let bar_content: Vec<u8> = read_from_file("bar.txt").await;
    foo_content.len() + bar_content.len()
}
```

foo 方法的执行有四种状态：未执行，读取文件中，发送中，发送结束，我们在实现 `Future trait` 时需要构造一个状态机

```rust

enum ContentLenState {
    Init,
    ReadingFromFoo {
        fut: impl Future<Output = Vec<u8>>
    },
    ReadingFromBar {
        foo_content: Vec<u8>,
        fut: impl Future<Output = Vec<u8>>
    },
    End
}

impl Future for ContentLenState {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            // 这里需要处理 pin，此处忽略
            match self {
                // 初始化第一个 future
                ContentLenState::Init => {
                    *self = ReadingFromFoo {
                        fut: read_from_file("foo.txt")
                    };
                }
                // poll 第一个 future，如果成功，则初始化第二个 future，否则返回 pending 等待下一次 poll
                ContentLenState::ReadingFromFoo { fut } => match fut.poll(cx) {
                    Poll::Ready(foo_content) => {
                        *self = ReadingFromBar {
                            foo_content,
                            fut: read_from_file("bar.txt")
                        };
                    },
                    Poll::Pending => return Poll::Pending,
                }
                // poll 第二个 future，如果成功，则返回 Poll::Ready 表示 future 完成，否则返回 pending 等待下一次 poll
                ContentLenState::ReadingFromBar {
                    foo_content,
                    fut,
                } => match fut {
                    Poll::Ready(bar_content) => {
                        *self = ContentLenState::End;
                        return Poll::Ready(foo_content.len() + bar_content.len());
                    },
                    Poll::Pending => return Poll::Pending,
                }
                // 返回 Poll::Ready 后不可以再对 Future 进行 poll
                End => panic!("poll called after Poll::Ready was returned")
            }
        }
    } 
}
```

我们来看看编译器是怎么实现的

rust 代码编译时，会产生多个中间编译产物，其中编译生成的 `HIR` 可以大致看出 async func 的实现思路，在 [Rust Playground](https://play.rust-lang.org/) 中可以直接生成 `HIR` 并查看, `HIR` 也可以在本地使用 Rust 工具链命令生成

我们从最简单的一个异步函数开始看
```rust
struct S;

impl Future for S {
    type Output = usize;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        Poll::Ready(1)
    }
}

async fn test() -> usize {
    S.await
}
```

test 方法的 HIR 长这个样子，可以看到，`.await` 语法糖，在脱糖后会展开成一段带有循环的代码

```rust
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;

async fn test()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    {
        {
                let _t =
                    {
                        match #[lang = "into_future"](S) {
                                mut __awaitee =>
                                    loop {
                                            match unsafe {
                                                            #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                #[lang = "get_context"](_task_context))
                                                        } {
                                                    #[lang = "Ready"] {  0: result } => break result,
                                                    #[lang = "Pending"] {} => { }
                                                }
                                            _task_context = (yield ());
                                        },
                            }
                    };
                _t
            }
    }
```

用标准库语法来美化一下

```rust
async fn test() -> /*impl Trait*/ {
    |mut _task_context: ResumeTy| {
        {
            let _t = {
                match IntoFuture::into_future(S) {
                    mut __awaitee => loop {
                        match unsafe {
                            Future::poll(
                                Pin::new_unchecked(&mut __awaitee),
                                std::future::get_context(_task_context),
                            )
                        } {
                            Poll::Ready(result) => break result,
                            Poll::Pending => {}
                        }
                        _task_context = (yield ());
                    },
                };
            };
            _t
        }
    }
}
```

看到 `yield` 关键字想到了什么？生成器！在 Rust 中，生成器也叫 [协程](https://doc.rust-lang.org/std/ops/trait.Coroutine.html), 在标准库中，目前为止还是一个 nightly 特性

```rust
pub trait Coroutine<R = ()> {
    type Yield;
    type Return;

    // Required method
    fn resume(
        self: Pin<&mut Self>,
        arg: R,
    ) -> CoroutineState<Self::Yield, Self::Return>;
}
```

它可以让用户很方便地实现一个状态机，当执行到 `yield` 时, `Coroutine` 会返回，并且会保存当前状态，当用户下次调用 `resume` 方法时，会从上次 `yield` 的地方恢复执行，上下文环境也会恢复到上次退出挂起的状态

```rust
let mut coroutine = #[coroutine] || {
    yield 1;
    "foo"
};
```

现在我们可以用进一步美化上面的示例，使他更贴近 Rust 语法

```rust
struct CoroutineFuture<C>(C);

fn test<C>() -> CoroutineFuture<C>
where
    C: Coroutine<ResumeTy, Yield = (), Return = ()>,
{
    |mut _task_context: ResumeTy| {
        let _t = {
            match IntoFuture::into_future(S) {
                mut __awaitee => loop {
                    match unsafe {
                        Future::poll(
                            Pin::new_unchecked(&mut __awaitee),
                            std::future::get_context(_task_context),
                        )
                    } {
                        Poll::Ready(result) => break result,
                        Poll::Pending => {}
                    }
                    _task_context = (yield ());
                },
            };
        };
        _t
    }
}
```

因为 `test` 方法返回一个 `Future`, 而 `Coroutine` 是没有实现 `Future trait` 的，所以编译器在这里有一些魔法，会把 `Coroutine` 转换为一个实现了 `Future trait` 的结构，类似于上面的 `CoroutineFuture`。而 `CoroutineFuture` 的实现如下

```rust

struct CoroutineFuture<C>(C);

impl<C: Coroutine<ResumeTy, Yield = ()>> Future for CoroutineFuture<C> {

    type Output = C::Return;
 
    fn poll(self: Pin<&mut Self>, ctx: &mut Context<'_>) -> Poll<Self::Output> {
        unsafe {
            let this: Pin<&mut C> = Pin::new_unchecked(&mut Pin::into_inner_unchecked(self).0);

            // 这里把 ctx 转换为 ResumeTy 参数，这里暂时使用伪代码代替
            let resume_ty = transmute_ctx_to_resumety(ctx);

            // 调用 resume 方法，时状态机取得进展
            match this.resume(resume_ty) {
                CoroutineState::Yielded(()) => Poll::Pending,
                CoroutineState::Complete(r) => Poll::Ready(r),
            }
        }
    }
}
```

`test` 方法返回的 `Future`, 在每次 `poll` 的时候，会对其内部的协程调用 `resume` 方法来获取进展

综上所述, `async` 和 `await` 这两个语法糖在编译器各自做了两件事：

1. `async` 将其包含的代码(`function` 或 `block`)转换为一个带有协程状态机的 `Future`, 每次 `poll` 时会调用 `resume` 方法使状态机取得进展
2. `await` 在协程里循环 `poll` 关联的 `future`, 在 `future` 返回 `pending` 时 `yield` 挂起协程，并在 `future` 结束后继续执行后续代码

现在我们再来看我们上面研究的 `content_len` 方法，它展开为 `HIR` 是这样的

```rust
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
async fn content_len()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    {
        {
                let _t =
                    {
                        let foo_content: Vec<u8> =
                            match #[lang = "into_future"](read_from_file("foo.txt")) {
                                    mut __awaitee =>
                                        loop {
                                                match unsafe {
                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                    #[lang = "get_context"](_task_context))
                                                            } {
                                                        #[lang = "Ready"] {  0: result } => break result,
                                                        #[lang = "Pending"] {} => { }
                                                    }
                                                _task_context = (yield ());
                                            },
                                };
                        let bar_content: Vec<u8> =
                            match #[lang = "into_future"](read_from_file("bar.txt")) {
                                    mut __awaitee =>
                                        loop {
                                                match unsafe {
                                                                #[lang = "poll"](#[lang = "new_unchecked"](&mut __awaitee),
                                                                    #[lang = "get_context"](_task_context))
                                                            } {
                                                        #[lang = "Ready"] {  0: result } => break result,
                                                        #[lang = "Pending"] {} => { }
                                                    }
                                                _task_context = (yield ());
                                            },
                                };
                        foo_content.len() + bar_content.len()
                    };
                _t
            }
    }

async fn read_from_file()
    ->
        /*impl Trait*/ |mut _task_context: ResumeTy|
    { { let _t = { ::alloc::vec::Vec::new() }; _t } }
```

在最后生成的状态机里，两个 `read_from_file` 方法各自生成里一段循环代码，因为 `Coroutine` 在 `yield` 时会保存状态，所以不需要再定义 `ContentLenState` 来手动维护状态

## Future trait 中的 Pin

在上面的讨论中，我们已经知道了 `async` 最后也是生成了一个 `Future trait`, 我们都注意到, `Future` 中的 `self` 的类型是 `Pin<&mut Self>`，这是为什么呢？在 [标准库文档](https://doc.rust-lang.org/std/pin/index.html) 中我们可以知道, Pin 包含的类型在内存中是不可移动的，与之相对应的是 `Unpin trait`, 它是一个 `auto trait`, 标准库定义的大部分类型都自动实现 `Unpin`, 如果你的结构中只包含 `Unpin` 类型的字段，那么也会自动实现 `Unpin trait`, 但是如果有其中一个字段是 `!Unpin` 的，就代表它没有实现 `Unpin`, 那么整个结构就是 `!Unpin` 的了。那么什么样的类型需要 `Pin` 呢？我们看下面的示例

```rust
#[derive(Debug)]
struct SelfRef {
    value: String,
    pointer_to_value: *const String,
}

impl SelfRef {
    fn new(txt: &str) -> Self {
        SelfRef {
            value: String::from(txt),
            pointer_to_value: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.value;
        self.pointer_to_value = self_ref;
    }

    fn value(&self) -> &str {
        &self.value
    }

    fn pointer_to_value(&self) -> &String {
        assert!(!self.pointer_to_value.is_null(),
            "Test::b called without Test::init being called first");
        unsafe { &*(self.pointer_to_value) }
    }
}
```

在这里, `SelfRef` 包含两个字段, `value` 存储一个 字符串, `pointer_to_value` 存储指向 `value` 字段的指针，这个结构就是自引用结构，如果这个结构在内存中发生了移动，比如 `value` 移动到了另一个内存块，那么 `pointer_to_value` 就失效了，这会带来很大的安全隐患。那么怎么保证 `SelfRef` 不会在内存中移动呢？答案就是 `Pin`

```rust
struct Unmovable {
    data: String,
    slice: NonNull<String>,
    _pin: PhantomPinned,
}

impl Unmovable {
    fn new(data: String) -> Pin<Box<Self>> {
        let res = Unmovable {
            data,
            slice: NonNull::dangling(),
            _pin: PhantomPinned,
        };
        let mut boxed = Box::pin(res);

        let slice = NonNull::from(&boxed.data);
        unsafe {
            let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);
            Pin::get_unchecked_mut(mut_ref).slice = slice;
        }
        boxed
    }
}
```

在 `Unmovable` 结构中, `_pin` 字段的类型 `PhantomPinned` 是 `!Unpin` 的，所以此时 `Unmovable` 是 `!Unpin` 的。构造出的 `Pin<Box<Unmovable>>` 不允许在内存中移动，如果有移动操作，会导致编译报错。

那么问题来了，在日常编写 `Future trait` 时，我们好像也没有定义过自引用结构，日常开发中也几乎没有见过，为什么 `Future trait` 要多此一举将 `self` 定义为 `Pin` 类型呢？原因在于 `async` 关键字生成的状态机里，自引用结构是很常见的，看下面的示例

```rust
async fn pin_example() -> i32 {
    let array = [1, 2, 3];
    let element = &array[2];
    async_write_file("foo.txt", element.to_string()).await;
    *element
}
```

上面的示例中, `element` 是对 `array` 变量的引用，在这个方法翻译为状态机时，因为 `array` 和 `element` 都存在，所以状态机会保存这两个变量，大概是这样

```rust
struct WaitingOnWriteState {
    array: [1, 2, 3],
    element: 0x1001c, // address of the last array element
}
```

可以看出，这时 `WaitingOnWriteState` 就是一个自引用结构，也就是说，在 `async` 代码中，只要有引用存在，最后状态机就会生成自引用结构，而这种场景实际上非常常见。这就是 `Future trait` 需要 `self` 为 `Pin` 类型的原因。

## Context, Excutor 和 Reactor

`Future trait` 中, `poll` 方法的第二个参数时 `Context` 类型，用于通知运行时 `Future` 已准备好 `poll`, 那么这个通知机制是如何实现的呢？运行时又是如何来调度 `Future` 任务并进行 `poll` 的呢？

`smol` 是个精简又功能完备的异步运行时，代码量不大且通俗易懂，我们可以从 `smol` 入手来学习异步运行时调度的底层原理（为便于讲解对实际代码进行了一定程度的精简）。

首先我们从 `smol::spawn` 开始，它接收一个 `Future`, 并在后台执行

```rust
// smol/src/spawn.rs
pub fn spawn<T: Send + 'static>(future: impl Future<Output = T> + Send + 'static) -> Task<T> {
    static GLOBAL: OnceCell<Executor<'_>> = OnceCell::new();

    fn global() -> &'static Executor<'static> {
        GLOBAL.get_or_init_blocking(|| {
            /* ... */

            for n in 1..=num_threads {
                thread::Builder::new()
                    .name(format!("smol-{}", n))
                    .spawn(|| loop { // 这个 loop 是为了在 block_on panic 后重新执行
                        catch_unwind(|| block_on(global().run(future::pending::<()>()))).ok();
                    })
                    .expect("cannot spawn executor thread");
            }

            Executor::new()
        })
    }

    // 把用户提交的 future 传入了执行器
    global().spawn(future)
}
```

`smol` 会构造一个全局唯一的执行器 `Executor`, 在后台启动多个线程, 在每个线程上运行执行器的 `run` 方法返回的 `Future`。

我们先来看 `block_on` 方法

```rust
// async-io/driver.rs: block_on
pub fn block_on<T>(future: impl Future<Output = T>) -> T {

    // Creates a parker and an associated waker that unparks it.
    fn parker_and_waker() -> (Parker, Waker, Arc<AtomicBool>) {
        // 用于将线程挂起和恢复线程执行
        let (p, u) = parking::pair();

        // This boolean is set to `true` when the current thread is blocked on I/O.
        let io_blocked = Arc::new(AtomicBool::new(false));

        // 这个 waker 可以将线程恢复执行
        let waker = BlockOnWaker::create(io_blocked.clone(), u);

        (p, waker, io_blocked)
    }

    thread_local! {
        // Cached parker and waker for efficiency.
        static CACHE: RefCell<(Parker, Waker, Arc<AtomicBool>)> = RefCell::new(parker_and_waker());

        // Indicates that the current thread is polling I/O, but not necessarily blocked on it.
        static IO_POLLING: Cell<bool> = const { Cell::new(false) };
    }

    struct BlockOnWaker {
        io_blocked: Arc<AtomicBool>,
        unparker: parking::Unparker,
    }

    impl BlockOnWaker {
        fn create(io_blocked: Arc<AtomicBool>, unparker: parking::Unparker) -> Waker {
            Waker::from(Arc::new(BlockOnWaker {
                io_blocked,
                unparker,
            }))
        }
    }

    impl std::task::Wake for BlockOnWaker {
        fn wake_by_ref(self: &Arc<Self>) {
            if self.unparker.unpark() {
                // Check if waking from another thread and if currently blocked on I/O.
                if !IO_POLLING.with(Cell::get) && self.io_blocked.load(Ordering::SeqCst) {
                    Reactor::get().notify();
                }
            }
        }

        fn wake(self: Arc<Self>) {
            self.wake_by_ref()
        }
    }

    CACHE.with(|cache| {

        let (p, waker, io_blocked) = /* get parker and waker */;

        pin!(future);

        // 构造一个 Context 用于执行 Future 的 poll 方法
        let cx = &mut Context::from_waker(waker);

        loop {
            // 对 Future 执行 poll，如果 future 完成则直接返回
            if let Poll::Ready(t) = future.as_mut().poll(cx) {
                p.park_timeout(Duration::from_secs(0));
                tracing::trace!("completed");
                return t;
            }

            // 接收到一个 unpark 调用
            if p.park_timeout(Duration::from_secs(0)) {
                tracing::trace!("notified");
                if let Some(mut reactor_lock) = Reactor::get().try_lock() {
                    // 推进一次 Reactor
                    reactor_lock.react(Some(Duration::from_secs(0))).ok();
                }
                continue;
            }

            // Try grabbing a lock on the reactor to wait on I/O.
            if let Some(mut reactor_lock) = Reactor::get().try_lock() {
                // Record the instant at which the lock was grabbed.
                let start = Instant::now();

                loop {
                    /* ... */

                    // Wait for I/O events.
                    tracing::trace!("waiting on I/O");
                    reactor_lock.react(None).ok();

                    // Check if a notification has been received.
                    if p.park_timeout(Duration::from_secs(0)) {
                        tracing::trace!("notified");
                        break;
                    }

                    // Check if this thread been handling I/O events for a long time.
                    if start.elapsed() > Duration::from_micros(500) {
                        tracing::trace!("stops hogging the reactor");

                        drop(reactor_lock);

                        // 尝试恢复 Reactor 的 mainloop 线程循环
                        unparker().unpark();

                        // 在当前线程等待
                        p.park();
                        break;
                    }
                }
            } else {
                // Wait for an actual notification.
                tracing::trace!("sleep until notification");
                p.park();
            }
        }
    })
}
```

在 `block_on` 中构造了 `parker` 和 `unparker`, 用来挂起线程和恢复线程. `BlockOnWaker` 是由 `unparker` 构造的，并且在 `wake` 方法里面调用了 `unpark`, 对执行器 `Future` 执行 `poll` 时，会把这个 `unparker` 作为 `Context` 参数传递。

当执行器 `Future` 返回 `pending` 时, `block_on` 会挂起线程，然后当执行器 `Future` 在内部调用了 `waker` 的 `wake` 方法时，又回恢复 `block_on` 的循环。稍后我们可以看到，执行器 `Future` 实际上永远不会返回 `Ready`, 所以 `block_on` 的循环永远不会退出。

可以注意到，在 `block_on` 每次循环中调用了 `Reactor::get()` 方法获取了一个全局的反应器的锁, 并且执行了 `Reactor::react` 方法。

```rust
// async-io/reactor.rs: ReactorLock::react
pub(crate) fn react(&mut self, timeout: Option<Duration>) -> io::Result<()> {
    let span = tracing::trace_span!("react");
    let _enter = span.enter();

    let mut wakers = Vec::new();

    // Process ready timers.
    let next_timer = self.reactor.process_timers(&mut wakers);

    /* ... */ 

    self.events.clear();

    // 在 poller 上阻塞等待 IO 事件
    let res = match self.reactor.poller.wait(&mut self.events, timeout) {
        // 没有 IO 事件发生
        Ok(0) => {
            // 收集就绪的定时器事件的 waker
            if timeout != Some(Duration::from_secs(0)) {
                self.reactor.process_timers(&mut wakers);
            }
            Ok(())
        }

        // 有就绪的 IO 事件发生
        Ok(_) => {
            let sources = self.reactor.sources.lock().unwrap();

            for ev in self.events.iter() {
                if let Some(source) = sources.get(ev.key) {
                    let mut state = source.state.lock().unwrap();

                    // 收集就绪的可读/可写 IO 事件的 waker，并移除出注册器
                    for &(dir, emitted) in &[(WRITE, ev.writable), (READ, ev.readable)] {
                        if emitted {
                            state[dir].tick = tick;
                            
                            state[dir].drain_into(&mut wakers);
                        }
                    }

                    // 把没有就绪的事件重新注册
                    if !state[READ].is_empty() || !state[WRITE].is_empty() {
                        // Create the event that we are interested in.
                        let event = {
                            let mut event = Event::none(source.key);
                            event.readable = !state[READ].is_empty();
                            event.writable = !state[WRITE].is_empty();
                            event
                        };

                        // Register interest in this event.
                        source.registration.modify(&self.reactor.poller, event)?;
                    }
                }
            }

            Ok(())
        }

        // The syscall was interrupted.
        Err(err) if err.kind() == io::ErrorKind::Interrupted => Ok(()),

        // An actual error occureed.
        Err(err) => Err(err),
    };

    // 批量调用所有已经就绪的 waker
    tracing::trace!("{} ready wakers", wakers.len());
    for waker in wakers {
        // Don't let a panicking waker blow everything up.
        panic::catch_unwind(|| waker.wake()).ok();
    }

    res
}
```

`Reactor` 是对操作系统底层 `epoll/kqueue` 等事件处理机制等封装，主要用来处理 `IO` 事件，以及对定时器 `Timer` 进行轮询。

1. 对于定时器，在创建后添加到 `Reactor` 中，此时是没有 `waker` 的，当第一次执行 `poll` 的时候，会设置 `waker` 到 `Timer` 中, `Reactor` 里轮询 `Timer` 并对所有到期的 `Timer` 执行 `wake` 操作。

2. 对于 `IO` 事件，创建后添加到 `Reactor` 的 `Poller` 中，此时也是没有 `waker` 的，当对读写操作执行 `poll`(`AsyncRead::poll_read`, `AsyncWrite::poll_write`)时，对读写事件设置 `waker`, `Reactor` 轮询时，获取到 `Poller` 中对应事件就绪后，调用对应的 `waker`

那么 `io` 事件和 `timer` 是怎么添加到 `Reactor` 的呢？
1. 在 `AsyncRead trait` 的 `poll_read` 方法中，可读事件被注册，在 `AsyncWrite` 的 `poll_write` 方法中，可写事件被注册
2. 在 `timer` 的构造方法如 `Timer::after` 等方法中，定时器事件被注册到 `Reactor` 上

在 `block_on` 方法中, `unpark` 方法会在一个新线程中启动一个 `Reactor mainloop` 循环

```rust
// async-io/driver.rs: unparker
fn unparker() -> &'static parking::Unparker {
    static UNPARKER: OnceCell<parking::Unparker> = OnceCell::new();

    UNPARKER.get_or_init_blocking(|| {
        let (parker, unparker) = parking::pair();

        thread::Builder::new()
            .name("async-io".to_string())
            .spawn(move || main_loop(parker))
            .expect("cannot spawn async-io thread");

        unparker
    })
}

// async-io/driver.rs: main_loop
fn main_loop(parker: parking::Parker) {
    let span = tracing::trace_span!("async_io::main_loop");
    let _enter = span.enter();

    // The last observed reactor tick.
    let mut last_tick = 0;
    // Number of sleeps since this thread has called `react()`.
    let mut sleeps = 0u64;

    loop {
        let tick = Reactor::get().ticker();

        if last_tick == tick {
            let reactor_lock = // 获取 reactor 锁;

            // Reactor 向前推动一次并更新 ticker
            if let Some(mut reactor_lock) = reactor_lock {
                tracing::trace!("waiting on I/O");
                reactor_lock.react(None).ok();
                last_tick = Reactor::get().ticker();
                sleeps = 0;
            }
        } else {
            last_tick = tick;
        }

        // 当前有 block_on 方法在执行时，block_on 循环也会调用 Reactor::react 方法并更新 ticker
        // 在这里阻塞等待并更新 ticker
        if BLOCK_ON_COUNT.load(Ordering::SeqCst) > 0 {
            // Exponential backoff from 50us to 10ms.
            let delay_us = [50, 75, 100, 250, 500, 750, 1000, 2500, 5000]
                .get(sleeps as usize)
                .unwrap_or(&10_000);

            tracing::trace!("sleeping for {} us", delay_us);
            if parker.park_timeout(Duration::from_micros(*delay_us)) {
                tracing::trace!("notified");

                // If notified before timeout, reset the last tick and the sleep counter.
                last_tick = Reactor::get().ticker();
                sleeps = 0;
            } else {
                sleeps += 1;
            }
        }
    }
}
```

接下来，我们再来看 `Executor::run` 方法

```rust
// async-executor/lib.rs: State::run
pub async fn run<T>(&self, future: impl Future<Output = T>) -> T {
    let mut runner = Runner::new(self);
    let mut rng = fastrand::Rng::new();

    // A future that runs tasks forever.
    let run_forever = async {
        loop {
            for _ in 0..200 {
                let runnable = runner.runnable(&mut rng).await;
                runnable.run();
            }
            future::yield_now().await;
        }
    };

    // Run `future` and `run_forever` concurrently until `future` completes.
    future.or(run_forever).await
}
```

在这里, `runner.runnable` 方法会获取一个任务并执行，满 200 次会挂起一下时当前线程可以执行参数传入的 `Future`, 在上面我们可以看到, 参数传入的是 `future::pending`, 意味着永远不会就绪，所以这里的 `run_forever` 会继续执行，并永远执行下去。

而 `block_on` 循环中，会不停的调用 `run` 返回的 `Future` 的 `poll` 方法，而这里的 `Future` 接收到的 `waker` 其实就是上文 `block_on` 方法传进来的 `unparker` 构造的 `waker`, 获取 `runnable` 任务和 `yield_now` 使用的都是这个 `waker`。

那么, `runner` 中的任务是哪里来的呢？在之前的 `smol::spawn` 中，其实用户传入的 `Future` 最后是传入了 `Executor::spawn`, 也就是说最后传入了执行器，而这里取出来的 `runnable` 任务，其实就是用户的 `Future` 构造的任务。

我们来看 `runnable` 的实现

```rust
// async-executor/lib.rs: Runner::runnable
async fn runnable(&mut self, rng: &mut fastrand::Rng) -> Runnable {
    let runnable = self
        .ticker
        .runnable_with(|| {
            // 先尝试从本地队列获取任务
            if let Ok(r) = self.local.pop() {
                return Some(r);
            }

            // 在尝试从全局队列中获取
            if let Ok(r) = self.state.queue.pop() {
                steal(&self.state.queue, &self.local);
                return Some(r);
            }

            // 尝试从其他线程的本地队列获取
            let local_queues = self.state.local_queues.read().unwrap();

            // Pick a random starting point in the iterator list and rotate the list.
            let n = local_queues.len();
            let start = rng.usize(..n);
            let iter = local_queues
                .iter()
                .chain(local_queues.iter())
                .skip(start)
                .take(n);

            // Remove this runner's local queue.
            let iter = iter.filter(|local| !Arc::ptr_eq(local, &self.local));

            // Try stealing from each local queue in the list.
            for local in iter {
                steal(local, &self.local);
                if let Ok(r) = self.local.pop() {
                    return Some(r);
                }
            }

            None
        })
        .await;

    // Bump the tick counter.
    self.ticks = self.ticks.wrapping_add(1);

    if self.ticks % 64 == 0 {
        // Steal tasks from the global queue to ensure fair task scheduling.
        steal(&self.state.queue, &self.local);
    }

    runnable
}
```

获取 `runnable` 任务时，会先尝试从本地队列获取，再尝试从全局队列获取，最后尝试从其他线程的本地队列中获取。

我们再来看任务是怎么在最开始放入队列中的，又是如何初始化为 `runnable` 的

```rust
// async-executor/lib.rs: Executor::spawn
pub fn spawn<T: Send + 'a>(&self, future: impl Future<Output = T> + Send + 'a) -> Task<T> {
    let mut active = self.state().active.lock().unwrap();

    // SAFETY: `T` and the future are `Send`.
    unsafe { self.spawn_inner(future, &mut active) }
}

// async-executor/lib.rs: Executor::spawn_inner
unsafe fn spawn_inner<T: 'a>(
    &self,
    future: impl Future<Output = T> + 'a,
    active: &mut Slab<Waker>,
) -> Task<T> {
    let entry = active.vacant_entry();
    let index = entry.key();
    let state = self.state_as_arc();
    let future = async move {
        let _guard = CallOnDrop(move || drop(state.active.lock().unwrap().try_remove(index)));
        future.await
    };

    // 在这里生成了 runnable
    let (runnable, task) = Builder::new()
        .propagate_panic(true)
        .spawn_unchecked(|()| future, self.schedule());
    entry.insert(runnable.waker());

    runnable.schedule();
    task
}

// async-task/runnable.rs: Builder::spawn_unchecked
pub unsafe fn spawn_unchecked<'a, F, Fut, S>(
    self,
    future: F,
    schedule: S,
) -> (Runnable<M>, Task<Fut::Output, M>)
where
    F: FnOnce(&'a M) -> Fut,
    Fut: Future + 'a,
    S: Schedule<M>,
    M: 'a,
{
    // 在 allocate 方法中生成了 RawTask，即 Runnable
    let ptr = if mem::size_of::<Fut>() >= 2048 {
        let future = |meta| {
            let future = future(meta);
            Box::pin(future)
        };

        RawTask::<_, Fut::Output, S, M>::allocate(future, schedule, self)
    } else {
        RawTask::<Fut, Fut::Output, S, M>::allocate(future, schedule, self)
    };

    let runnable = Runnable::from_raw(ptr);
    let task = Task {
        ptr,
        _marker: PhantomData,
    };
    (runnable, task)
}

// async-executor/raw.rs: RawTask::wake_by_ref
pub(crate) fn allocate<'a, Gen: FnOnce(&'a M) -> F>(
    future: Gen,
    schedule: S,
    builder: crate::Builder<M>,
) -> NonNull<()>
where
    F: 'a,
    M: 'a,
{
    // Compute the layout of the task for allocation. Abort if the computation fails.
    //
    // n.b. notgull: task_layout now automatically aborts instead of panicking
    let task_layout = Self::task_layout();

    unsafe {
        // Allocate enough space for the entire task.
        let ptr = match NonNull::new(alloc::alloc::alloc(task_layout.layout) as *mut ()) {
            None => abort(),
            Some(p) => p,
        };

        let raw = Self::from_ptr(ptr.as_ptr());

        // 初始化 RawTask，这里忽略。。。

        // schedule 闭包被设置到 RawTask 的 schedule 字段中
        (raw.schedule as *mut S).write(schedule);

        // Generate the future, now that the metadata has been pinned in place.
        let future = abort_on_panic(|| future(&(*raw.header).metadata));

        // 用户的 future 被设置到 RawTask 的 future 字段中
        raw.future.write(future);

        ptr
    }
}
```

这里有两个关键点，一个是用户传入的 `future`, 一个是 `schedule` 闭包，在 `spawn_inner` 中，生成 `runnable` 后，有两步操作

1. 设置了任务的 `waker` 到一个叫 `active` 中, 说明这个时候, `runnable` 任务的 `waker` 已经生成出来了
2. 调用了一次 `schedule` 方法

这个 `waker` 是怎么生成的呢？通过查找调用了 `RawTask` 的 `schedule` 字段的引用，我们看到在 `RawTask` 的 `wake_by_ref` 方法中调用了这个 `schedule`

```rust
// async-executor/raw.rs: RawTask::wake_by_ref
unsafe fn wake_by_ref(ptr: *const ()) {
    let raw = Self::from_ptr(ptr);

    let mut state = (*raw.header).state.load(Ordering::Acquire);

    loop {
        // If the task is completed or closed, it can't be woken up.
        if state & (COMPLETED | CLOSED) != 0 {
            break;
        }

        // If the task is already scheduled, we just need to synchronize with the thread that
        // will run the task by "publishing" our current view of the memory.
        if state & SCHEDULED != 0 {
            // 省略。。。
        } else {
            // 省略。。。

            // Mark the task as scheduled.
            match (*raw.header).state.compare_exchange_weak(
                state,
                new,
                Ordering::AcqRel,
                Ordering::Acquire,
            ) {
                Ok(_) => {
                    // If the task is not running, now is the time to schedule.
                    if state & RUNNING == 0 {
                        // If the reference count overflowed, abort.
                        if state > isize::MAX as usize {
                            abort();
                        }

                        // 在这里从 Runnable 获取了 RawTask 并调用了 schedule 方法
                        let task = Runnable::from_raw(NonNull::new_unchecked(ptr as *mut ()));
                        (*raw.schedule).schedule(task, ScheduleInfo::new(false));
                    }

                    break;
                }
                Err(s) => state = s,
            }
        }
    }
}
```

再往上追溯，我们看到了一个定义在 `RawTask` 中的 `VTable`

```rust
// async-executor/raw.rs: RawTask
const RAW_WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(
    Self::clone_waker,
    Self::wake,
    Self::wake_by_ref,
    Self::drop_waker,
);
```

这个 `VTable` 会在 `RawTask` 的 `run` 方法中使用，用来生成 `waker`, 即标准库中构造 `Waker` 的方法 [RawWaker::new](https://doc.rust-lang.org/stable/std/task/struct.RawWaker.html#method.new), 而 `run` 方法又会在 `runnable` 的 `run` 方法中调用，即上面 `Executor::spawn` 中循环做的事情

`RawTask::run` 我们看一下做了什么

```rust
// async-executor/raw.rs: RawTask::run
unsafe fn run(ptr: *const ()) -> bool {
    let raw = Self::from_ptr(ptr);

    // VTable 生成 waker 进而生成 Context
    let waker = ManuallyDrop::new(Waker::from_raw(RawWaker::new(ptr, &Self::RAW_WAKER_VTABLE)));
    let cx = &mut Context::from_waker(&waker);

    let mut state = (*raw.header).state.load(Ordering::Acquire);

    // 省略部分代码。。。

    // 在这里，根据是否是 std 环境来调用 raw.future 的 poll 方法，传入的 context 是上面用 VTable 生成出来的
    #[cfg(not(feature = "std"))]
    let poll = <F as Future>::poll(Pin::new_unchecked(&mut *raw.future), cx).map(Ok);

    #[cfg(feature = "std")]
    let poll = {
        // Check if we should propagate panics.
        if (*raw.header).propagate_panic {
            // Use catch_unwind to catch the panic.
            match std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                <F as Future>::poll(Pin::new_unchecked(&mut *raw.future), cx)
            })) {
                Ok(Poll::Ready(v)) => Poll::Ready(Ok(v)),
                Ok(Poll::Pending) => Poll::Pending,
                Err(e) => Poll::Ready(Err(e)),
            }
        } else {
            <F as Future>::poll(Pin::new_unchecked(&mut *raw.future), cx).map(Ok)
        }
    };

    mem::forget(guard);

    match poll {
        Poll::Ready(out) => {
            // Future 返回了 Ready，则将结果写入 raw.output
            Self::drop_future(ptr);
            raw.output.write(out);

            // 省略部分代码
        }
        Poll::Pending => {
            let mut future_dropped = false;

            // The task is still not completed.
            loop {
                // 省略

                // Mark the task as not running.
                match (*raw.header).state.compare_exchange_weak(
                    state,
                    new,
                    Ordering::AcqRel,
                    Ordering::Acquire,
                ) {
                    Ok(state) => {
                        
                        if state & CLOSED != 0 {
                            // 省略。。。
                        } else if state & SCHEDULED != 0 {
                            // 这里再次调用了任务的 schedule 方法重新调度
                            Self::schedule(ptr, ScheduleInfo::new(true));
                            return true;
                        } else {
                            // Drop the task reference.
                            Self::drop_ref(ptr);
                        }
                        break;
                    }
                    Err(s) => state = s,
                }
            }
        }
    }

    return false;
}
```

在 `run` 方法中，会调用用户传入 `future` 的 `poll` 方法，如果 `ready` 则写入结果，如果 `pending` 则调用 `schedule` 方法再一次调度。

而传入 `future` 的 `waker` 的 `wake` 方法在 `future` 就绪时也会调用 `schedule`, 那么这个 `schedule` 到底做了什么呢？在 `spawn_inner` 方法中我们可以看到，传入的 `schedule` 方法其实是 `Executor::schedule` 方法

```rust
// async-executor/lib.rs: Executor::schedule
fn schedule(&self) -> impl Fn(Runnable) + Send + Sync + 'static {
    let state = self.state_as_arc();

    // TODO: If possible, push into the current local queue and notify the ticker.
    move |runnable| {
        state.queue.push(runnable).unwrap();
        // 通知没有之前没有获取到任务而休眠的线程
        state.notify();
    }
}

// async-executor/lib.rs: Ticker::runnable_with
async fn runnable_with(&mut self, mut search: impl FnMut() -> Option<Runnable>) -> Runnable {
    future::poll_fn(|cx| {
        loop {
            match search() {
                None => {
                    // 没找到任务，准备休眠
                    if !self.sleep(cx.waker()) {
                        // If already sleeping and unnotified, return.
                        return Poll::Pending;
                    }
                }
                Some(r) => {
                    // Wake up.
                    self.wake();

                    // Notify another ticker now to pick up where this ticker left off, just in
                    // case running the task takes a long time.
                    self.state.notify();

                    return Poll::Ready(r);
                }
            }
        }
    })
    .await
}

// async-executor/lib.rs: Ticker::sleep
fn sleep(&mut self, waker: &Waker) -> bool {
    let mut sleepers = self.state.sleepers.lock().unwrap();

    match self.sleeping {
        // Move to sleeping state.
        0 => {
            self.sleeping = sleepers.insert(waker);
        }

        // Already sleeping, check if notified.
        id => {
            if !sleepers.update(id, waker) {
                return false;
            }
        }
    }

    self.state
        .notified
        .store(sleepers.is_notified(), Ordering::Release);

    true
}

// async-executor/lib.rs: State::notiify
fn notify(&self) {
    if self
        .notified
        .compare_exchange(false, true, Ordering::AcqRel, Ordering::Acquire)
        .is_ok()
    {
        // 唤醒休眠的空闲线程
        let waker = self.sleepers.lock().unwrap().notify();
        if let Some(w) = waker {
            w.wake();
        }
    }
}
```

在这里目前的实现是直接放入了全局队列，而由上面的代码可知

1. 在工作窃取时，线程会把全局队列和其他线程本地队列的任务窃取到自己的本地队列中。作者也写了个 TODO, 希望调度时当前线程的任务首先可以放入自己的本地队列中。
2. 如果没有找到任何任务，即当前线程空闲，则进入休眠状态，将 `waker` 注册到 `sleepers` 中，返回 `pending`, 使得 `Executor::run` 方法陷入等待，最后在 `block_on` 方法中 `park`, 即没有任务执行的空闲线程会 `park`, 然后等待被 `schedule` 函数唤醒，即被任务 `waker` 唤醒


目前我们就大致明白了, `spawn` 时，执行器会先把任务放到全局队列，然后在循环中从队列中拿任务执行直到 `pending`, 当再次调度或者是 `future` 就绪由 `future` 调用了 `wake` 方法时，会把任务再次放入队列等待下一次执行。

## 其它类型的 Future

我们已经知道, `IO` 和 `Timer Future` 是由 `Reactor` 统一调度的，那么其他 `Future` 类型如 `asyn-channel`, `async-lock` 等的等待和恢复执行呢？实际上这些类型可以通过时间通知机制来实现，我们以 `async-channel` 为例

### Sender

```rust
// async-channel/lib.rs
impl<'a, T> EventListenerFuture for SendInner<'a, T> {
    type Output = Result<(), SendError<T>>;

    fn poll_with_strategy<'x, S: Strategy<'x>>(
        self: Pin<&mut Self>,
        strategy: &mut S,
        context: &mut S::Context,
    ) -> Poll<Result<(), SendError<T>>> {
        let this = self.project();

        loop {
            let msg = this.msg.take().unwrap();
            // 尝试发送
            match this.sender.try_send(msg) {
                Ok(()) => return Poll::Ready(Ok(())),
                Err(TrySendError::Closed(msg)) => return Poll::Ready(Err(SendError(msg))),
                Err(TrySendError::Full(m)) => *this.msg = Some(m),
            }

            // 队列已满，则在 listener 的 future 上等待
            if this.listener.is_some() {
                ready!(S::poll(strategy, &mut *this.listener, context));
            } else {
                *this.listener = Some(this.sender.channel.send_ops.listen());
            }
        }
    }
}

// async-channel/lib.rs: Sender::try_send
pub fn try_send(&self, msg: T) -> Result<(), TrySendError<T>> {
    match self.channel.queue.push(msg) {
        // 成功写入到队列
        Ok(()) => {
            // 尝试唤醒 lisener 来恢复因为队列空而等待的 receiver
            self.channel.recv_ops.notify_additional(1);
            self.channel.stream_ops.notify(usize::MAX);
            Ok(())
        }
        Err(PushError::Full(msg)) => Err(TrySendError::Full(msg)),
        Err(PushError::Closed(msg)) => Err(TrySendError::Closed(msg)),
    }
}
```

### Receiver

```rust
// async-channel/lib.rs
impl<T> Stream for Receiver<T> {
    type Item = T;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        loop {
            // 如果已经在一个 listener 的 future 上等待了，则继续等待
            {
                let this = self.as_mut().project();
                if let Some(listener) = this.listener.as_mut() {
                    ready!(Pin::new(listener).poll(cx));
                    *this.listener = None;
                }
            }

            loop {
                // Attempt to receive a message.
                match self.try_recv() {
                    Ok(msg) => {
                        // 获取到消息，将 listener 置为空
                        let this = self.as_mut().project();
                        *this.listener = None;
                        return Poll::Ready(Some(msg));
                    }
                    Err(TryRecvError::Closed) => {
                        // The stream is not blocked on an event - drop the listener.
                        let this = self.as_mut().project();
                        *this.listener = None;
                        return Poll::Ready(None);
                    }
                    Err(TryRecvError::Empty) => {}
                }

                // 队列为空，则设置 listner 阻塞
                let this = self.as_mut().project();
                if this.listener.is_some() {
                    // Go back to the outer loop to wait for a notification.
                    break;
                } else {
                    *this.listener = Some(this.channel.stream_ops.listen());
                }
            }
        }
    }
}

// async-channel/lib.rs: Receiver::try_recv
pub fn try_recv(&self) -> Result<T, TryRecvError> {
    match self.channel.queue.pop() {
        // 成功取出一个消息
        Ok(msg) => {
            // 尝试唤醒 lisener 来恢复因为队列满而阻塞等待的 sender
            self.channel.send_ops.notify_additional(1);

            Ok(msg)
        }
        Err(PopError::Empty) => Err(TryRecvError::Empty),
        Err(PopError::Closed) => Err(TryRecvError::Closed),
    }
}
```

而 listener 等待的 poll 实现

```rust
// event-listener/lib.rs: InnerListener::poll_internal
fn poll_internal(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {
    let this = self.project();
    let inner = (*this.event).borrow();

    // 注册并获取当前状态
    match inner
        .register(this.listener, TaskRef::Waker(cx.waker()))
        .notified()
    {
        Some(tag) => {
            // 状态为 notified，则返回 ready
            Poll::Ready(tag)
        }

        None => {
            // 否则继续等待
            Poll::Pending
        }
    }
}
```

实际上是对 `listener` 进行注册，当另一段的调用 `notify` 方法时, 会发送一个通知, `listener` 会返回 `notified`, 否则继续等待。

而对端在就绪后，不仅会调用 `notify` 来通知 `lisener`, 也会调用这里保存的 `waker` 的 `wake()` 方法来通知运行时进行调度。

```rust
// event-listener/std.rs: Inner::notify
fn notify(&mut self, mut notify: impl Notification<Tag = T>) -> usize {
    // 获取需要 notify 的个数
    let mut n = notify.count(Internal::new());
    let is_additional = notify.is_additional(Internal::new());

    if !is_additional {
        if n < self.notified {
            return 0;
        }
        n -= self.notified;
    }

    let original_count = n;
    while n > 0 {
        n -= 1;

        // 对链表中的 listener 逐个调用 wake 方法进行通知，并更新其状态为 notified
        match self.next {
            None => return original_count - n - 1,

            Some(e) => {
                // Get the entry and move the pointer forwards.
                let entry = unsafe { e.as_ref() };
                self.next = entry.next.get();

                // Set the state to `Notified` and notify.
                let tag = notify.next_tag(Internal::new());
                if let State::Task(task) = entry.state.replace(State::Notified {
                    additional: is_additional,
                    tag,
                }) {
                    // 在这里调用了任务中存储的 wake 方法通知就绪
                    task.wake();
                }

                // Bump the notified count.
                self.notified += 1;
            }
        }
    }

    original_count - n
}
```

# 参考资料

* https://rust-lang.github.io/async-book/02_execution/02_future.html
* https://users.rust-lang.org/t/how-does-the-compiler-convert-the-await-to-the-invocation-of-poll/107339
* https://users.rust-lang.org/t/about-desugar-of-expr-await/94844
* https://tmandry.gitlab.io/blog/posts/optimizing-await-1/
* https://tmandry.gitlab.io/blog/posts/optimizing-await-2/
* https://doc.rust-lang.org/reference/expressions/await-expr.html#await-expressions
* https://doc.rust-lang.org/reference/expressions/block-expr.html#async-context
* https://os.phil-opp.com/async-await/
* https://course.rs/advance/circle-self-ref/self-referential.html
* https://github.com/smol-rs/smol.git
* https://github.com/smol-rs/async-channel.git
* https://github.com/smol-rs/async-io.git
* https://github.com/smol-rs/polling.git
* https://github.com/smol-rs/async-task.git
* https://github.com/smol-rs/async-executor.git
* https://github.com/smol-rs/async-task.git
* https://github.com/smol-rs/event-listener.git
